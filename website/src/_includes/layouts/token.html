<!DOCTYPE html>
<html lang="{{ page.url | getlang }}"
    {% for language in languages.languages %}
        {% if language.label == page.url | getlang %}
            dir="{{ "rtl" if language.rtl else "ltr" }}"
        {% endif %}
    {% endfor %}>

  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>{{ title }}</title>
    <meta name="Content-Type" content="text/html;charset=utf-8" />
    <meta http-equiv="onion-location" content="{% cfg 'onionLocation' %}{{ permalink }}" />
    <meta property="og:url" content="{% cfg 'siteLocation' %}{{ permalink }}" />
    <meta property="og:type" content="article" />
    <meta property="og:title" content="{{ title }}" />
    <meta property="og:image" content="{% cfg 'siteLocation' %}/img/share_simplex.png" />
    <meta name="twitter:card" content="summary" />
    <link rel="icon" type="image/png" sizes="96x96" href="/img/favicon.ico" />
    <link href="/css/tailwind.css" rel="stylesheet" />
    <link rel="stylesheet" href="/css/blog.css" />
    <link id="prism-theme" rel="stylesheet" href="/css/prism-light.min.css"/>
    <link href="/css/style.css" rel="stylesheet" />
    <link rel="stylesheet" href="/css/design3-nav.css">
    <script src="/js/ethers.umd.min.js"></script>
    <script async defer src="https://buttons.github.io/buttons.js"></script>
</head>

  <body class="bg-[#F3F6F7] dark:bg-[#0C0B13]">
    {% include "navbar.html" %}

    <section id="article" class="container mb-[75px] bg-white dark:bg-[#17203D] px-5 mt-[66px]">
      <div class="py-6 md:p-[60px]">{{ content | safe }}</div>
    </section>

    <div id="mint-simplex-nft" class="overlay hidden fixed top-0 left-0 bottom-0 right-0 before:absolute before:w-full before:h-full bg-transparent before:bg-secondary-bg-light dark:before:bg-primary-bg-dark before:opacity-90 items-center justify-center p-3 md:p-10 z-[10000]">
        <div class="overlay-card w-full md:w-fit md:max-w-[1276px] bg-white dark:bg-card-bg-dark opacity-100 h-full md:h-fit md:max-h-[660px] z-[10001] rounded-md shadow-[0px_3px_12px_rgba(0,0,0,0.2)] p-6 py-10 sm:p-14 overflow-auto scale-100">
            <div id="app-content"></div>

            <script>
                window.addEventListener("hashchange", showNftApp);
                window.addEventListener("load", showNftApp);

                function showNftApp() {
                    if (window.location.hash === "#mint-simplex-nft") {
                        if (!window.appState) initNftApp(); // TODO rename, maybe make local
                        renderNftApp(); // TODO rename, maybe make local
                    }
                }

                const selectedNetwork = 'hoodi'; // Options: 'ethereum', 'arbitrum', 'hoodi'
                const networks = {
                    ethereum: {
                        chainId: '0x1',
                        minterAddress: ''
                    },
                    arbitrum: {
                        chainId: '0xa4b1',
                        minterAddress: ''
                    },
                    hoodi: {
                        chainId: '0x88bb0',
                        minterAddress: '0xF587D636FDb67F292D1C2381Cf38c70d661e1F3D' // TODO update contract
                    }
                };
                const currentConfig = networks[selectedNetwork];
                const minterAddress = currentConfig.minterAddress;

                const nftABI = [
                    'function balanceOf(address owner) view returns (uint)',
                    'function tokenOfOwnerByIndex(address owner, uint index) view returns (uint)',
                    'function tokenURI(uint tokenId) view returns (string)',
                    'function mintingLocked() view returns (bool)',
                    'function nextTokenId() view returns (uint)',
                    'function nextTokenURI() view returns (string)',
                    'function totalSupply() view returns (uint)'
                ];

                const minterABI = [
                    'function nft() view returns (address)',
                    'function mintStartTime() view returns (uint)', // TODO update contract
                    'function mintEndTime() view returns (uint)',
                    'function paused()', // TODO update contract
                    'function mint()'
                ];

                const STATES = {
                    NOT_CONNECTED: 'not_connected',
                    LOADING: 'loading',
                    OWNED: 'owned',
                    NO_NFT: 'no_nft',
                    MINTING: 'minting',
                    MINTED: 'minted',
                    ERROR: 'error'
                };

                let appState;
                let provider;
                let signer;
                let nftContract;
                let minterContract;
                let nextPollInterval;
                let mintPollInterval;

                function initNftApp() {
                    appState = {
                        state: STATES.NOT_CONNECTED,
                        address: '',
                        nftAddress: '',
                        hasToken: false,
                        tokenId: null,
                        metadata: null,
                        nextId: null,
                        nextUri: null,
                        nextMetadata: null,
                        totalSupply: null,
                        canMint: true,
                        currentTime: null,
                        mintStartTime: 0,
                        mintEndTime: 0,
                        paused: false,
                        locked: false,
                        error: null,
                        lastRetry: null
                    };

                    if (window.ethereum) {
                        window.ethereum.on('accountsChanged', async accounts => {
                            if (accounts.length > 0) {
                                await loadAccount(accounts);
                            } else {
                                resetConnection();
                            }
                            renderNftApp();
                        });

                        window.ethereum.on('chainChanged', () => {
                            window.location.reload();
                        });
                    }
                }

                function resetConnection() {
                    appState.state = STATES.NOT_CONNECTED;
                    appState.address = '';
                    provider = null;
                    signer = null;
                    nftContract = null;
                    minterContract = null;
                }

                async function connectWallet() {
                    if (!window.ethereum) {
                        appState.state = STATES.NOT_CONNECTED;
                        renderNftApp();
                        return;
                    }

                    try {
                        const accounts = await window.ethereum.request({ method: 'eth_requestAccounts' });
                        await loadAccount(accounts);
                    } catch (error) {
                        handleError(error, connectWallet);
                    }
                }

                async function loadAccount(accounts) {
                    appState.address = accounts[0];
                    provider = new ethers.BrowserProvider(window.ethereum);
                    signer = await provider.getSigner();
                    const network = await provider.getNetwork();

                    if (network.chainId.toString(16) !== currentConfig.chainId.slice(2).toLowerCase()) {
                        await window.ethereum.request({
                            method: 'wallet_switchEthereumChain',
                            params: [{ chainId: currentConfig.chainId }]
                        });
                    }

                    minterContract = new ethers.Contract(minterAddress, minterABI, signer);

                    appState.state = STATES.LOADING;
                    renderNftApp();
                    await loadData();
                }

                async function switchAccount() {
                    try {
                        await window.ethereum.request({
                            method: 'wallet_requestPermissions',
                            params: [{ eth_accounts: {} }]
                        });
                    } catch (error) {
                        handleError(error, switchAccount);
                    }
                }

                async function loadData() { // TODO rename, make local
                    try {
                        appState.nftAddress = await minterContract.nft();
                        nftContract = new ethers.Contract(appState.nftAddress, nftABI, signer);
                        await checkCanMint();
                        await checkBalance();
                    } catch (error) {
                        handleError(error, loadData);
                    }
                }

                async function checkCanMint() {
                    appState.locked = await nftContract.mintingLocked();
                    appState.mintStartTime = Number(await minterContract.mintStartTime());
                    appState.mintEndTime = Number(await minterContract.mintEndTime());
                    appState.paused = await minterContract.paused();
                    appState.currentTime = Math.floor(Date.now() / 1000);
                    appState.canMint = !appState.locked
                        && !appState.paused
                        && appState.currentTime >= appState.mintStartTime
                        && appState.currentTime < appState.mintEndTime;
                }

                async function checkBalance() {
                    appState.totalSupply = Number(await nftContract.totalSupply());
                    const balance = Number(await nftContract.balanceOf(appState.address));
                    if (balance > 0) {
                        appState.hasToken = true;
                        appState.tokenId = Number(await nftContract.tokenOfOwnerByIndex(appState.address, 0));
                        const uri = await nftContract.tokenURI(appState.tokenId);
                        appState.metadata = await loadMetadata(uri);
                        appState.state = STATES.OWNED;
                    } else {
                        appState.hasToken = false;
                        await loadNext();
                        appState.state = STATES.NO_NFT;
                        startNextPolling();
                    }
                    renderNftApp();
                }

                async function loadNext() {
                    if (!appState.canMint) return;
                    try {
                        appState.totalSupply = Number(await nftContract.totalSupply());
                        const newNextId = Number(await nftContract.nextTokenId());
                        const newNextUri = await nftContract.nextTokenURI();
                        if (newNextId !== appState.nextId || newNextUri !== appState.nextUri) {
                            appState.nextId = newNextId;
                            if (newNextUri !== appState.nextUri) {
                                appState.nextUri = newNextUri;
                                appState.nextMetadata = await loadMetadata(newNextUri);
                            }
                        }
                    } catch (error) {
                        console.error('Failed to load next:', error);
                    }
                }

                function replaceIPFS(uri) {
                    return uri ? uri.replace(/^ipfs:\/\//, 'https://ipfs.io/ipfs/') : '';
                }

                async function loadMetadata(uri) {
                    let proxyUri = replaceIPFS(uri)
                    const response = await fetch(proxyUri);
                    return await response.json();
                }

                function startNextPolling() {
                    if (nextPollInterval) clearInterval(nextPollInterval);
                    nextPollInterval = setInterval(async () => {
                        if (appState.state === STATES.NO_NFT) {
                            await checkCanMint();
                            await loadNext();
                            renderNftApp();
                        } else {
                            clearInterval(nextPollInterval);
                            nextPollInterval = null;
                        }
                    }, 5000);
                }

                async function mintNft() {
                    if (!appState.canMint) return;
                    appState.state = STATES.MINTING;
                    renderNftApp();
                    try {
                        const tx = await minterContract.mint();
                        await tx.wait();
                        mintPollInterval = setInterval(async () => {
                            try {
                                const balance = Number(await nftContract.balanceOf(appState.address));
                                if (balance > 0) {
                                    clearInterval(mintPollInterval);
                                    mintPollInterval = null;
                                    appState.hasToken = true;
                                    appState.tokenId = Number(await nftContract.tokenOfOwnerByIndex(appState.address, 0));
                                    const uri = await nftContract.tokenURI(appState.tokenId);
                                    appState.metadata = await loadMetadata(uri);
                                    appState.state = STATES.MINTED;
                                    renderNftApp();
                                }
                            } catch (error) {
                                // TODO show error
                                console.error('Polling error:', error);
                            }
                        }, 5000);
                    } catch (error) {
                        handleError(error, mintNft);
                        appState.state = STATES.NO_NFT;
                        renderNftApp();
                    }
                }

                function handleError(error, retryFunc) {
                    console.log(error);
                    appState.error = error.reason || error.message || 'An unknown error occurred';
                    appState.lastRetry = retryFunc;
                    appState.state = STATES.ERROR;
                    renderNftApp();
                }

                function renderNftApp() {
                    const content = document.getElementById('app-content');
                    content.innerHTML = Number.isFinite(appState.totalSupply)
                        ? `Total SimpleX NFT minted: ${appState.totalSupply}`
                        : '';

                    if (appState.address) {
                        const ellipsisAddr = appState.address.slice(0, 6) + '...' + appState.address.slice(-4);
                        content.innerHTML += `<p>Connected: ${ellipsisAddr}</p>`;
                        content.innerHTML += `<button id="switchAccount">Switch Account</button>`;
                        setTimeout(() => document.getElementById('switchAccount').onclick = switchAccount, 0);
                    }

                    switch (appState.state) {
                        case STATES.NOT_CONNECTED:
                            if (!window.ethereum) {
                                content.innerHTML += `<p>No MetaMask detected. Please install it.</p><a href="https://metamask.io/download/" target="_blank">Install MetaMask</a>`;
                            }
                            content.innerHTML += `<button id="connect">Connect Wallet</button>`;
                            setTimeout(() => document.getElementById('connect').onclick = connectWallet, 0);
                            break;

                        case STATES.LOADING:
                            content.innerHTML += `<div class="spinner">Loading...</div>`; // TODO CSS for .spinner
                            break;

                        case STATES.MINTED:
                        case STATES.OWNED:
                            content.innerHTML += appState.state == STATES.MINTED
                                ? `<p>Congratulations! You minted SimpleX NFT #${appState.tokenId}.</p>` // TODO animation CSS
                                : `<p>You have SimpleX NFT #${appState.tokenId}</p>`;
                            const meta = appState.metadata;
                            if (meta) {
                                if (meta.image) {
                                    content.innerHTML += `<img src="${replaceIPFS(meta.image)}" alt="NFT Image" style="max-width: 300px;">`;
                                }
                                content.innerHTML += `<p>Name: ${meta.name || 'N/A'}</p>`;
                                content.innerHTML += `<p>Description: ${meta.description || 'N/A'}</p>`;
                                if (Array.isArray(meta.attributes)) {
                                    for (attr of meta.attributes) {
                                        if (attr.trait_type && attr.value) {
                                            content.innerHTML += `<p>${attr.trait_type}: ${attr.value}</p>`;
                                        }
                                    }
                                }
                            }
                            break;

                        case STATES.NO_NFT:
                            if (appState.canMint) {
                                content.innerHTML += `<p>Next NFT #${appState.nextId}</p>`;
                                const nextMeta = appState.nextMetadata;
                                if (nextMeta) {
                                    if (nextMeta.image) {
                                        content.innerHTML += `<img src="${replaceIPFS(nextMeta.image)}" alt="Next NFT Image" style="max-width: 300px;">`;
                                    }
                                    content.innerHTML += `<p>Name: ${nextMeta.name || 'N/A'}</p>`;
                                    content.innerHTML += `<p>Description: ${nextMeta.description || 'N/A'}</p>`;
                                    if (Array.isArray(nextMeta.attributes)) {
                                    for (attr of nextMeta.attributes) {
                                        if (attr.trait_type && attr.value) {
                                            content.innerHTML += `<p>${attr.trait_type}: ${attr.value}</p>`;
                                        }
                                    }
                                }
                                }
                                content.innerHTML += `<button id="mintBtn">Mint #${appState.nextId}</button>`;
                                setTimeout(() => document.getElementById('mintBtn').onclick = mintNft, 0);
                            } else if (appState.locked) {
                                content.innerHTML += `<p>NFT minting ended.</p>`;
                            } else if (appState.paused) {
                                content.innerHTML += `<p>NFT minting is temporarily paused.</p>`;
                            } else {
                                if (appState.currentTime > appState.mintEndTime) {
                                    const endDate = new Date(appState.mintEndTime * 1000).toLocaleString();
                                    content.innerHTML += `<p>Minting ended on ${endDate}.</p>`;
                                } else if (appState.currentTime <= appState.mintStartTime) {
                                    const startDate = new Date(appState.mintEndTime * 1000).toLocaleString();
                                    content.innerHTML += `<p>Minting will start on ${startDate}.</p>`;
                                }
                            }
                            break;

                        case STATES.MINTING:
                            content.innerHTML += `<div class="spinner">Minting... Please wait.</div>`;
                            break;

                        case STATES.ERROR:
                            content.innerHTML += `<p>Error: ${appState.error}</p>`;
                            content.innerHTML += `<button id="retry">Retry</button>`;
                            setTimeout(() => document.getElementById('retry').onclick = async () => {
                                appState.error = null;
                                appState.state = STATES.LOADING;
                                renderNftApp();
                                try {
                                    await appState.lastRetry();
                                } catch (error) {
                                    handleError(error, appState.lastRetry);
                                }
                            }, 0);
                            break;
                    }
                }
            </script>

            <svg class="close-overlay-btn" id="cross" width="16" height="16" viewBox="0 0 13 13" xmlns="http://www.w3.org/2000/svg">
                <path d="M12.7973 11.5525L7.59762 6.49833L12.7947 1.44675C13.055 1.19371 13.0658 0.771991 12.8188 0.505331C12.5718 0.238674 12.1602 0.227644 11.8999 0.480681L6.65343 5.58028L1.09979 0.182228C0.839522 -0.070157 0.427909 -0.059127 0.18094 0.207531C-0.0660305 0.474191 -0.0552645 0.895911 0.205003 1.14894L5.70862 6.49833L0.20247 11.851C-0.0577975 12.104 -0.0685635 12.5257 0.178407 12.7924C0.306324 12.9306 0.477936 13 0.650181 13C0.811033 13 0.971873 12.9397 1.09726 12.817L6.65343 7.41639L11.9025 12.5186C12.0285 12.6406 12.1893 12.7015 12.3495 12.7015C12.5218 12.7015 12.6934 12.6321 12.8213 12.4939C13.0689 12.2273 13.0582 11.8062 12.7973 11.5525Z"/>
            </svg>
        </div>
    </div>

    {% include "footer.html" %}
    <script src="/js/prism.min.js"></script>
    <script src="/js/swiper-bundle.min.js"></script>
    <script src="/js/script.js"></script>
</body>

</html>
