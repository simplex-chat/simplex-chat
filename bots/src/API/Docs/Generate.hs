{-# LANGUAGE DuplicateRecordFields #-}
{-# LANGUAGE LambdaCase #-}
{-# LANGUAGE NamedFieldPuns #-}
{-# LANGUAGE OverloadedStrings #-}

module API.Docs.Generate where

import API.Docs.Commands
import API.Docs.Events
import API.Docs.Responses
import API.Docs.Syntax
import API.Docs.Types
import API.TypeInfo
import Control.Monad
import Data.Char (isSpace, isUpper, toLower, toUpper)
import Data.List (intercalate)
import qualified Data.List.NonEmpty as L
import qualified Data.Set as S
import Data.Text (Text)
import qualified Data.Text as T
import qualified Data.Text.IO as T
import Simplex.Messaging.Parsers (dropPrefix)
import System.IO

commandsDocFile :: FilePath
commandsDocFile = "./bots/api/COMMANDS.md"

eventsDocFile :: FilePath
eventsDocFile = "./bots/api/EVENTS.md"

typesDocFile :: FilePath
typesDocFile = "./bots/api/TYPES.md"

generateCommandsDoc :: IO ()
generateCommandsDoc =
  withFile commandsDocFile WriteMode $ \h -> do
    hPutStrLn h $ "# API Commands and Responses\n\n" <> autoGenerated
    let docTypes = S.fromList $ map docTypeName chatTypesDocs
    forM_ chatCommandsDocs $ \CCCategory {categoryName, commands} -> do
      hPutStrLn h $ "\n" <> withLink "" categoryName
      forM_ commands $ \CCDoc {consName} ->
        hPutStrLn h $ "- " <> withLink "" consName
    hPutStrLn h "\n---"
    forM_ chatCommandsDocs $ \CCCategory {categoryName, categoryDescr, commands} -> do
      hPutStrLn h $ "\n\n## " <> categoryName <> "\n\n" <> categoryDescr
      forM_ commands $ \CCDoc {consName, commandType = cmd@RecordTypeInfo {fieldInfos = params}, commandDescr, responses, syntax} -> do
        T.hPutStrLn h $ "\n\n### " <> T.pack consName <> "\n\n" <> commandDescr
        unless (null params) $ do
          hPutStrLn h "\n**Parameters**:"
          printFields h "./TYPES.md" docTypes Nothing params
        unless (null syntax) $ do
          hPutStrLn h $ "\n**Syntax**:\n"
          hPutStrLn h $ "```\n" <> intercalate "\n" (map (renderDocSyntax cmd) syntax) <> "\n```\n"
          unless (all isConst syntax) $ hPutStrLn h $ "```javascript\n" <> intercalate "\n" (map (renderJSSyntax cmd) syntax) <> (if length syntax == 1 then " // JavaScript" else "") <> "\n```"
        hPutStrLn h $ if length responses > 1 then "\n**Responses**:" else "\n**Response**:"
        forM_ responses $ \CRDoc {consName = name, responseType = RecordTypeInfo {fieldInfos}, responseDescr} -> do
          let respType = dropPrefix "CR" name
              respDescr = if null responseDescr then camelToSpace respType else responseDescr
          hPutStrLn h $ "\n" <> fstToUpper respType <> ": " <> respDescr <> "."
          printFields h "./TYPES.md" docTypes (Just respType) fieldInfos
        hPutStrLn h "\n---"

camelToSpace :: String -> String
camelToSpace [] = []
camelToSpace (x : xs) = toUpper x : go xs
  where
    go [] = []
    go (y : ys)
      | isUpper y = ' ' : toLower y : go ys
      | otherwise = y : go ys

generateEventsDoc :: IO ()
generateEventsDoc =
  withFile eventsDocFile WriteMode $ \h -> do
    hPutStrLn h $ "# API Events\n\n" <> autoGenerated
    let docTypes = S.fromList $ map docTypeName chatTypesDocs
    forM_ chatEventsDocs $ \CECategory {categoryName, mainEvents, otherEvents} -> do
      hPutStrLn h $ "\n" <> withLink "" categoryName
      let hasOthers = not $ null otherEvents
          indent = if hasOthers then "  " else ""
      when hasOthers $ hPutStrLn h $ "- Main event" <> plural mainEvents
      printList h indent mainEvents
      when hasOthers $ do
        hPutStrLn h $ "- Other event" <> plural otherEvents
        printList h indent otherEvents
    hPutStrLn h "\n---"
    forM_ chatEventsDocs $ \CECategory {categoryName, categoryDescr, mainEvents, otherEvents} -> do
      hPutStrLn h $ "\n\n## " <> categoryName <> "\n\n" <> categoryDescr
      forM_ (mainEvents ++ otherEvents) $ \CEDoc {consName, eventType = RecordTypeInfo {fieldInfos}, eventDescr} -> do
        let evtType = dropPrefix "CEvt" consName
            evtDescr = if null eventDescr then camelToSpace evtType <> "." else eventDescr
        hPutStrLn h $ "\n\n### " <> fstToUpper evtType <> "\n\n" <> evtDescr
        hPutStrLn h "\n**Record type**:"
        printFields h "./TYPES.md" docTypes (Just evtType) fieldInfos
        hPutStrLn h "\n---"
  where
    printList h indent = mapM_ $ \CEDoc {consName} -> hPutStrLn h $ indent <> "- " <> withLink "" (dropPrefix "CEvt" consName)
    plural evts = if length evts == 1 then "" else "s"

-- TODO remove once switched to CTDoc'
printFields :: Handle -> FilePath -> S.Set ConsName -> Maybe String -> [FieldInfo] -> IO ()
printFields h docPath docTypes tag_ fields = do
  forM_ tag_ $ \tag -> hPutStrLn h $ "- type: \"" <> tag <> "\""
  forM_ fields $ \FieldInfo {fieldName, typeInfo} ->
    hPutStrLn h $ "- " <> fieldName <> ": " <> fieldType typeInfo
  where
    fieldType = \case
      TIType t -> simpleType t
      TIOptional t -> fieldType t <> "?"
      TIArray {elemType, nonEmpty = _} -> "[" <> fieldType elemType <> "]" -- <> (if nonEmpty then " // (non-empty)" else "") -- removed because it has to "pop" out of maybe
      TIMap {keyType, valueType} -> "{" <> simpleType keyType <> " : " <> fieldType valueType <> "}"
    simpleType (ST t _ps)
      | t `S.member` docTypes = withLink docPath t
      | otherwise = t

typesDocText :: Text
typesDocText =
  "# API Types\n\n" <> T.pack autoGenerated <> "\n"
    <> foldMap (\t -> T.pack $ "\n- " <> withLink "" (docTypeName' t)) chatTypesDocs' <> "\n"
    <> foldMap typeDocText chatTypesDocs'
  where
    typeDocText CTDoc' {typeDefinition = APITypeDef {typeName' = name, typeDef}, typeDescr} =
      "\n\n---\n\n## " <> T.pack name <> "\n"
        <> (if T.null typeDescr then "" else "\n" <> typeDescr <> "\n")
        <> typeDefText typeDef
    typeDefText = \case
      ATDRecord fields -> "\n**Record type**:\n" <> fieldsText "" (L.toList fields)
      ATDEnum cs -> "\n**Enum type**:\n" <> foldMap (\m -> "- \"" <> T.pack m <> "\"\n") cs
      ATDUnion cs -> "\n**Discriminated union type**:\n" <> foldMap constrText cs
        where
          constrText (ATUnionMember tag fields) =
            ("\n" <> T.pack (fstToUpper tag) <> ":\n")
              <> ("- type: \"" <> T.pack tag <> "\"\n")
              <> (fieldsText "" fields)

fieldsText :: FilePath -> [APIRecordField] -> Text
fieldsText docPath = foldMap $ T.pack . fieldText
  where
    fieldText (APIRecordField name t) = "- " <> name <> ": " <> typeText t <> "\n"
    typeText = \case
      ATPrim (PT t) -> t
      ATDef (APITypeDef t _) -> withLink docPath t
      ATRef t -> withLink docPath t
      ATOptional t -> typeText t <> "?"
      ATArray {elemType} -> "[" <> typeText elemType <> "]"
      ATMap (PT t) valueType -> "{" <> t <> " : " <> typeText valueType <> "}"

autoGenerated :: String
autoGenerated = "This file is generated automatically."

withLink :: FilePath -> String -> String
withLink docPath s = "[" <> s <> "](" <> docPath <> "#" <> headerAnchor s <> ")"
  where
    headerAnchor = map $ \c -> if isSpace c then '-' else toLower c

fstToUpper :: String -> String
fstToUpper "" = ""
fstToUpper (h : t) = toUpper h : t
