{-# LANGUAGE DuplicateRecordFields #-}
{-# LANGUAGE LambdaCase #-}
{-# LANGUAGE NamedFieldPuns #-}
{-# LANGUAGE OverloadedStrings #-}

module API.Docs.Generate where

import API.Docs.Commands
import API.Docs.Events
import API.Docs.Responses
import API.Docs.Syntax
import API.Docs.Types
import API.TypeInfo
import Control.Monad
import Data.Char (isSpace, isUpper, toLower, toUpper)
import Data.List (find, intercalate, sortOn)
import qualified Data.Set as S
import qualified Data.Text as T
import qualified Data.Text.IO as T
import Simplex.Messaging.Parsers (dropPrefix, fstToLower)
import System.IO

commandsDocFile :: FilePath
commandsDocFile = "./bots/api/COMMANDS.md"

eventsDocFile :: FilePath
eventsDocFile = "./bots/api/EVENTS.md"

typesDocFile :: FilePath
typesDocFile = "./bots/api/TYPES.md"

generateCommandsDoc :: IO ()
generateCommandsDoc =
  withFile commandsDocFile WriteMode $ \h -> do
    hPutStrLn h $ "# API Commands and Responses\n\n" <> autoGenerated
    let docTypes = S.fromList $ map docTypeName chatTypesDocs
    forM_ chatCommandsDocs $ \CCCategory {categoryName, commands} -> do
      hPutStrLn h $ "\n" <> withLink "" categoryName
      forM_ commands $ \CCDoc {consName} ->
        hPutStrLn h $ "- " <> withLink "" consName
    hPutStrLn h "\n---"
    forM_ chatCommandsDocs $ \CCCategory {categoryName, categoryDescr, commands} -> do
      hPutStrLn h $ "\n\n## " <> categoryName <> "\n\n" <> categoryDescr
      forM_ commands $ \CCDoc {consName, commandDescr, responses, syntax} -> do
        T.hPutStrLn h $ "\n\n### " <> T.pack consName <> "\n\n" <> commandDescr
        case find ((consName ==) . consName') chatCommandsTypeInfo of
          Nothing -> error "Missing command type info"
          Just cmd@RecordTypeInfo {fieldInfos = params} -> do
            unless (null params) $ do
              hPutStrLn h "\n**Parameters**:"
              printFields h "./TYPES.md" docTypes Nothing params
            unless (null syntax) $ do
              hPutStrLn h $ "\n**Syntax**:\n"
              hPutStrLn h $ "```\n" <> intercalate "\n" (map (renderDocSyntax cmd) syntax) <> "\n```\n"
              unless (all isConst syntax) $ hPutStrLn h $ "```javascript\n" <> intercalate "\n" (map (renderJSSyntax cmd) syntax) <> (if length syntax == 1 then " // JavaScript" else "") <> "\n```"
            hPutStrLn h $ if length responses > 1 then "\n**Responses**:" else "\n**Response**:"
            forM_ responses $ \name ->
              case (find ((name ==) . consName') chatResponsesTypeInfo, find ((name ==) . consName') chatResponsesDocs) of
                (Just RecordTypeInfo {fieldInfos}, Just CRDoc {responseDescr}) -> do
                  let respType = dropPrefix "CR" name
                      respDescr = if null responseDescr then camelToSpace respType else responseDescr
                  hPutStrLn h $ "\n" <> fstToUpper respType <> ": " <> respDescr <> "."
                  printFields h "./TYPES.md" docTypes (Just respType) fieldInfos
                _ -> error "Missing response type info or doc"
            hPutStrLn h "\n---"

camelToSpace :: String -> String
camelToSpace [] = []
camelToSpace (x : xs) = toUpper x : go xs
  where
    go [] = []
    go (y : ys)
      | isUpper y = ' ' : toLower y : go ys
      | otherwise = y : go ys

generateEventsDoc :: IO ()
generateEventsDoc =
  withFile eventsDocFile WriteMode $ \h -> do
    hPutStrLn h $ "# API Events\n\n" <> autoGenerated
    let docTypes = S.fromList $ map docTypeName chatTypesDocs
    forM_ chatEventsDocs $ \CECategory {categoryName, mainEvents, otherEvents} -> do
      hPutStrLn h $ "\n" <> withLink "" categoryName
      let hasOthers = not $ null otherEvents
          indent = if hasOthers then "  " else ""
      when hasOthers $ hPutStrLn h $ "- Main event" <> plural mainEvents
      printList h indent mainEvents
      when hasOthers $ do
        hPutStrLn h $ "- Other event" <> plural otherEvents
        printList h indent otherEvents
    hPutStrLn h "\n---"
    forM_ chatEventsDocs $ \CECategory {categoryName, categoryDescr, mainEvents, otherEvents} -> do
      hPutStrLn h $ "\n\n## " <> categoryName <> "\n\n" <> categoryDescr
      forM_ (mainEvents ++ otherEvents) $ \CEDoc {consName, eventDescr} -> do
        let evtType = dropPrefix "CEvt" consName
            evtDescr = if null eventDescr then camelToSpace evtType <> "." else eventDescr
        hPutStrLn h $ "\n\n### " <> fstToUpper evtType <> "\n\n" <> evtDescr
        case find ((consName ==) . consName') chatEventsTypeInfo of
          Nothing -> error "Missing event type info"
          Just RecordTypeInfo {fieldInfos} -> do
            hPutStrLn h "\n**Record type**:"
            printFields h "./TYPES.md" docTypes (Just evtType) fieldInfos
            hPutStrLn h "\n---"
  where
    printList h indent = mapM_ $ \CEDoc {consName} -> hPutStrLn h $ indent <> "- " <> withLink "" (dropPrefix "CEvt" consName)
    plural evts = if length evts == 1 then "" else "s"

printFields :: Handle -> FilePath -> S.Set ConsName -> Maybe String -> [FieldInfo] -> IO ()
printFields h docPath docTypes tag_ fields = do
  forM_ tag_ $ \tag -> hPutStrLn h $ "- type: \"" <> tag <> "\""
  forM_ fields $ \FieldInfo {fieldName, typeInfo} ->
    hPutStrLn h $ "- " <> fieldName <> ": " <> fieldType typeInfo
  where
    fieldType = \case
      TIType t -> simpleType t
      TIOptional t -> fieldType t <> "?"
      TIArray {elemType, nonEmpty = _} -> "[" <> fieldType elemType <> "]" -- <> (if nonEmpty then " // (non-empty)" else "") -- removed because it has to "pop" out of maybe
      TIMap {keyType, valueType} -> "{" <> simpleType keyType <> " : " <> fieldType valueType <> "}"
    simpleType (ST t _ps)
      | t `S.member` docTypes = withLink docPath t
      | otherwise = t

generateTypesDoc :: IO ()
generateTypesDoc = do
  withFile typesDocFile WriteMode $ \h -> do
    hPutStrLn h $ "# API Types\n\n" <> autoGenerated <> "\n"
    let ctds = sortOn docTypeName chatTypesDocs
        docTypes = S.fromList $ map docTypeName chatTypesDocs
    forM_ ctds $ \t -> do
      let name = docTypeName t
      hPutStrLn h $ "- " <> withLink "" name
    forM_ ctds $ \CTDoc {typeInfo = STI name constrs, jsonEncoding, consPrefix, typeDescr} -> do
      hPutStrLn h $ "\n\n---\n\n## " <> name
      unless (T.null typeDescr) $ T.hPutStrLn h $ "\n" <> typeDescr
      case constrs of
        [] -> pure ()
        RecordTypeInfo {fieldInfos = fields} : _ -> case jsonEncoding of
          Just STRecord
            | length constrs > 1 -> error $ "No sum encoding for type: " <> name
            | otherwise -> do
                hPutStrLn h $ "\n**Record type**:"
                printFields h "" docTypes Nothing fields
          Just STUnion -> do
            hPutStrLn h $ "\n**Discriminated union type**:"
            forM_ constrs $ \RecordTypeInfo {consName, fieldInfos} -> do
              let tag = normalizeConsName consPrefix consName
              hPutStrLn h $ "\n" <> fstToUpper tag <> ":"
              printFields h "" docTypes (Just tag) fieldInfos
          Just STEnum -> do
            hPutStrLn h $ "\n**Enum type**:"
            forM_ constrs $ \RecordTypeInfo {consName, fieldInfos} -> do
              unless (null fieldInfos) $ error $ "Enum encoding with fields: " <> name
              hPutStrLn h $ "- \"" <> normalizeConsName consPrefix consName <> "\""
          Just (STEnum' f) -> do
            hPutStrLn h $ "\n**Enum type**:"
            forM_ constrs $ mapM_  (\tag -> hPutStrLn h $ "- \"" <> tag <> "\"") . f
          Nothing -> pure ()

normalizeConsName :: String -> ConsName -> ConsName
normalizeConsName pfx consName
  | null pfx && uppercase = consName
  | null pfx = fstToLower consName
  | uppercase = map toUpper noPfx
  | otherwise = noPfx
  where
    uppercase = all (\c -> isUpper c || c == '_') consName
    noPfx = dropPrefix pfx consName

autoGenerated :: String
autoGenerated = "This file is generated automatically."

withLink :: FilePath -> String -> String
withLink docPath s = "[" <> s <> "](" <> docPath <> "#" <> headerAnchor s <> ")"
  where
    headerAnchor = map $ \c -> if isSpace c then '-' else toLower c

fstToUpper :: String -> String
fstToUpper "" = ""
fstToUpper (h : t) = toUpper h : t
