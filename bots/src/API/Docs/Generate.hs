{-# LANGUAGE DuplicateRecordFields #-}
{-# LANGUAGE LambdaCase #-}
{-# LANGUAGE NamedFieldPuns #-}
{-# LANGUAGE OverloadedStrings #-}

module API.Docs.Generate where

import API.Docs.Commands
import API.Docs.Responses
import API.Docs.Types
import API.TypeInfo
import Control.Monad
import Data.Char (isSpace, isUpper, toLower, toUpper)
import Data.List (find, sortOn)
import qualified Data.Set as S
import Data.Text (Text)
import qualified Data.Text as T
import qualified Data.Text.IO as T
import Simplex.Messaging.Parsers (dropPrefix, fstToLower)
import System.IO

commandsDocFile :: FilePath
commandsDocFile = "./bots/api/COMMANDS.md"

typesDocFile :: FilePath
typesDocFile = "./bots/api/TYPES.md"

generateCommandsDoc :: IO ()
generateCommandsDoc =
  withFile commandsDocFile WriteMode $ \h -> do
    hPutStrLn h $ "# API Commands and Responses\n\n" <> autoGenerated
    let docTypes = S.fromList $ map docTypeName chatTypesDocs
    forM_ chatCommandsDocs $ \CCCategory {categoryName, commands} -> do
      T.hPutStrLn h $ "\n[" <> categoryName <> "](#" <> headerAnchor categoryName <> ")"
      forM_ commands $ \CCDoc {consName} ->
        T.hPutStrLn h $ "- [" <> T.pack consName <> "](#" <> headerAnchor (T.pack consName) <> ")"
    hPutStrLn h ""
    forM_ chatCommandsDocs $ \CCCategory {categoryName, categoryDescr, commands} -> do
      T.hPutStrLn h $ "\n## " <> categoryName <> "\n\n" <> categoryDescr
      forM_ commands $ \CCDoc {consName, commandDescr, responses} -> do
        T.hPutStrLn h $ "\n\n### " <> T.pack consName <> "\n\n" <> commandDescr
        case find ((consName ==) . consName') chatCommandsTypeInfo of
          Just RecordTypeInfo {fieldInfos = params}
            | length params == 0 -> pure ()
            | otherwise -> do
                hPutStrLn h "\n**Parameters**:"
                printFields h "./TYPES.md" docTypes params
          Nothing -> error "Missing command type info"
        if length responses > 1
          then hPutStrLn h "\n**Responses**:"
          else hPutStr h "\n**Response**: "
        forM_ responses $ \name ->
          case (find ((name ==) . consName') chatResponsesTypeInfo, find ((name ==) . consName') chatResponsesDocs) of
            (Just RecordTypeInfo {fieldInfos}, Just CRDoc {responseDescr}) -> do
              let respType = dropPrefix "CR" name
                  respDescr = if T.null responseDescr then camelToSpace respType else T.unpack responseDescr
              when (length responses > 1) $ hPutStrLn h ""
              hPutStrLn h $ respDescr <> "."
              hPutStrLn h $ "- type: \"" <> respType <> "\""
              printFields h "./TYPES.md" docTypes fieldInfos
            _ -> error "Missing type info or response description"
  where
    camelToSpace :: String -> String
    camelToSpace [] = []
    camelToSpace (x : xs) = toUpper x : go xs
      where
        go [] = []
        go (y : ys)
          | isUpper y = ' ' : toLower y : go ys
          | otherwise = y : go ys

printFields :: Handle -> Text -> S.Set ConsName -> [FieldInfo] -> IO ()
printFields h docPath docTypes =
  mapM_ $ \FieldInfo {fieldName, typeInfo} ->
    T.hPutStrLn h $ "- " <> T.pack fieldName <> ": " <> fieldType typeInfo
  where
    fieldType = \case
      TIType t -> simpleType t
      TIOptional t -> fieldType t <> "?"
      TIArray {elemType, nonEmpty = _} -> "[" <> fieldType elemType <> "]" -- <> (if nonEmpty then " // (non-empty)" else "") -- removed because it has to "pop" out of maybe
      TIMap {keyType, valueType} -> "{" <> simpleType keyType <> " : " <> fieldType valueType <> "}"
    simpleType (STI t _ps)
      | t `S.member` docTypes = "[" <> t' <> "](" <> docPath <> "#" <> headerAnchor t' <> ")"
      | otherwise = t'
      where
        t' = T.pack t

generateTypesDoc :: IO ()
generateTypesDoc = do
  withFile typesDocFile WriteMode $ \h -> do
    hPutStrLn h $ "# API Types\n\n" <> autoGenerated <> "\n"
    let ctds = sortOn docTypeName chatTypesDocs
        docTypes = S.fromList $ map docTypeName chatTypesDocs
    forM_ ctds $ \t -> do
      let name = T.pack $ docTypeName t
      T.hPutStrLn h $ "- [" <> name <> "](#" <> headerAnchor name <> ")"
    forM_ ctds $ \CTDoc {typeInfo = SumTypeInfo name records, jsonEncoding, consPrefix, typeDescr} -> do
      T.hPutStrLn h $ "\n\n## " <> T.pack name
      unless (T.null typeDescr) $ T.hPutStrLn h $ "\n" <> typeDescr
      case records of
        [] -> pure ()
        RecordTypeInfo {fieldInfos = fields} : _ -> case jsonEncoding of
          Just STRecord
            | length records > 1 -> error $ "No sum encoding for type: " <> name
            | otherwise -> do
                hPutStrLn h $ "\n**Record type**:"
                printFields h "" docTypes fields
          Just STUnion -> do
            hPutStrLn h $ "\n**Discriminated union type**:"
            forM_ records $ \RecordTypeInfo {consName, fieldInfos} -> do
              let tag = if null consPrefix then fstToLower consName else dropPrefix consPrefix consName
              hPutStrLn h $ "\nRecord " <> fstToUpper tag <> ":"
              hPutStrLn h $ "- type: \"" <> tag <> "\""
              printFields h "" docTypes fieldInfos
          Just STEnum -> do
            hPutStrLn h $ "\n**Enum type**:"
            forM_ records $ \RecordTypeInfo {consName, fieldInfos} -> do
              unless (null fieldInfos) $ error $ "Enum encoding with fields: " <> name
              let tag = if null consPrefix then fstToLower consName else dropPrefix consPrefix consName
              hPutStrLn h $ "- \"" <> tag <> "\""
          Just (STEnum' f) -> do
            hPutStrLn h $ "\n**Enum type**:"
            forM_ records $ mapM_  (\tag -> hPutStrLn h $ "- \"" <> tag <> "\"") . f
          Nothing -> pure ()

autoGenerated :: String
autoGenerated = "This file is generated automatically."

headerAnchor :: Text -> Text
headerAnchor = T.pack . map (\c -> if isSpace c then '-' else toLower c) . T.unpack

fstToUpper :: String -> String
fstToUpper "" = ""
fstToUpper (h : t) = toUpper h : t
