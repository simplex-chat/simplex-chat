{-# LANGUAGE DuplicateRecordFields #-}
{-# LANGUAGE LambdaCase #-}
{-# LANGUAGE NamedFieldPuns #-}
{-# LANGUAGE OverloadedStrings #-}

module API.Docs.Generate where

import API.Docs.Commands
import API.Docs.Responses
import API.Docs.Types
import API.TypeInfo
import Control.Monad
import Data.Char (isSpace, isUpper, toLower, toUpper)
import Data.List (find, sortOn)
import qualified Data.Set as S
import qualified Data.Text as T
import qualified Data.Text.IO as T
import Simplex.Messaging.Parsers (dropPrefix, fstToLower)
import System.IO

commandsDocFile :: FilePath
commandsDocFile = "./bots/api/COMMANDS.md"

typesDocFile :: FilePath
typesDocFile = "./bots/api/TYPES.md"

generateCommandsDoc :: IO ()
generateCommandsDoc =
  withFile commandsDocFile WriteMode $ \h -> do
    hPutStrLn h $ "# API Commands and Responses\n\n" <> autoGenerated
    let docTypes = S.fromList $ map docTypeName chatTypesDocs
    forM_ chatCommandsDocs $ \CCCategory {categoryName, commands} -> do
      hPutStrLn h $ "\n" <> withLink "" categoryName
      forM_ commands $ \CCDoc {consName} ->
        hPutStrLn h $ "- " <> withLink "" consName
    hPutStrLn h "\n---"
    forM_ chatCommandsDocs $ \CCCategory {categoryName, categoryDescr, commands} -> do
      hPutStrLn h $ "\n\n## " <> categoryName <> "\n\n" <> categoryDescr
      forM_ commands $ \CCDoc {consName, commandDescr, responses} -> do
        T.hPutStrLn h $ "\n\n### " <> T.pack consName <> "\n\n" <> commandDescr
        case find ((consName ==) . consName') chatCommandsTypeInfo of
          Just RecordTypeInfo {fieldInfos = params}
            | length params == 0 -> pure ()
            | otherwise -> do
                hPutStrLn h "\n**Parameters**:"
                printFields h "./TYPES.md" docTypes Nothing params
          Nothing -> error "Missing command type info"
        hPutStrLn h $ if length responses > 1 then "\n**Responses**:" else "\n**Response**:"
        forM_ responses $ \name ->
          case (find ((name ==) . consName') chatResponsesTypeInfo, find ((name ==) . consName') chatResponsesDocs) of
            (Just RecordTypeInfo {fieldInfos}, Just CRDoc {responseDescr}) -> do
              let respType = dropPrefix "CR" name
                  respDescr = if null responseDescr then camelToSpace respType else responseDescr
              hPutStrLn h $ "\n" <> fstToUpper respType <> ": " <> respDescr <> "."
              printFields h "./TYPES.md" docTypes (Just respType) fieldInfos
            _ -> error "Missing type info or response description"
        hPutStrLn h "\n---"
  where
    camelToSpace :: String -> String
    camelToSpace [] = []
    camelToSpace (x : xs) = toUpper x : go xs
      where
        go [] = []
        go (y : ys)
          | isUpper y = ' ' : toLower y : go ys
          | otherwise = y : go ys

printFields :: Handle -> FilePath -> S.Set ConsName -> Maybe String -> [FieldInfo] -> IO ()
printFields h docPath docTypes tag_ fields = do
  forM_ tag_ $ \tag -> hPutStrLn h $ "- type: \"" <> tag <> "\""
  forM_ fields $ \FieldInfo {fieldName, typeInfo} ->
    hPutStrLn h $ "- " <> fieldName <> ": " <> fieldType typeInfo
  where
    fieldType = \case
      TIType t -> simpleType t
      TIOptional t -> fieldType t <> "?"
      TIArray {elemType, nonEmpty = _} -> "[" <> fieldType elemType <> "]" -- <> (if nonEmpty then " // (non-empty)" else "") -- removed because it has to "pop" out of maybe
      TIMap {keyType, valueType} -> "{" <> simpleType keyType <> " : " <> fieldType valueType <> "}"
    simpleType (ST t _ps)
      | t `S.member` docTypes = withLink docPath t
      | otherwise = t

generateTypesDoc :: IO ()
generateTypesDoc = do
  withFile typesDocFile WriteMode $ \h -> do
    hPutStrLn h $ "# API Types\n\n" <> autoGenerated <> "\n"
    let ctds = sortOn docTypeName chatTypesDocs
        docTypes = S.fromList $ map docTypeName chatTypesDocs
    forM_ ctds $ \t -> do
      let name = docTypeName t
      hPutStrLn h $ "- " <> withLink "" name
    forM_ ctds $ \CTDoc {typeInfo = STI name records, jsonEncoding, consPrefix, typeDescr} -> do
      hPutStrLn h $ "\n\n---\n\n## " <> name
      unless (T.null typeDescr) $ T.hPutStrLn h $ "\n" <> typeDescr
      case records of
        [] -> pure ()
        RecordTypeInfo {fieldInfos = fields} : _ -> case jsonEncoding of
          Just STRecord
            | length records > 1 -> error $ "No sum encoding for type: " <> name
            | otherwise -> do
                hPutStrLn h $ "\n**Record type**:"
                printFields h "" docTypes Nothing fields
          Just STUnion -> do
            hPutStrLn h $ "\n**Discriminated union type**:"
            forM_ records $ \RecordTypeInfo {consName, fieldInfos} -> do
              let tag = if null consPrefix then fstToLower consName else dropPrefix consPrefix consName
              hPutStrLn h $ "\n" <> fstToUpper tag <> ":"
              printFields h "" docTypes (Just tag) fieldInfos
          Just STEnum -> do
            hPutStrLn h $ "\n**Enum type**:"
            forM_ records $ \RecordTypeInfo {consName, fieldInfos} -> do
              unless (null fieldInfos) $ error $ "Enum encoding with fields: " <> name
              let tag = if null consPrefix then fstToLower consName else dropPrefix consPrefix consName
              hPutStrLn h $ "- \"" <> tag <> "\""
          Just (STEnum' f) -> do
            hPutStrLn h $ "\n**Enum type**:"
            forM_ records $ mapM_  (\tag -> hPutStrLn h $ "- \"" <> tag <> "\"") . f
          Nothing -> pure ()

autoGenerated :: String
autoGenerated = "This file is generated automatically."

withLink :: FilePath -> String -> String
withLink docPath s = "[" <> s <> "](" <> docPath <> "#" <> headerAnchor s <> ")"
  where
    headerAnchor = map $ \c -> if isSpace c then '-' else toLower c

fstToUpper :: String -> String
fstToUpper "" = ""
fstToUpper (h : t) = toUpper h : t
