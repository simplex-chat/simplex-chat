{-# LANGUAGE DuplicateRecordFields #-}
{-# LANGUAGE LambdaCase #-}
{-# LANGUAGE NamedFieldPuns #-}
{-# LANGUAGE OverloadedStrings #-}

module API.Docs.Generate.TypeScript where

import API.Docs.Commands
import API.Docs.Events
import API.Docs.Generate
import API.Docs.Responses
import API.Docs.Syntax
import API.Docs.Types
import API.TypeInfo
import Data.Char (isSpace, isUpper, toLower, toUpper)
import qualified Data.List.NonEmpty as L
import Data.Text (Text)
import qualified Data.Text as T

typesCodeFile :: FilePath
typesCodeFile = "./packages/simplex-chat-client/types/typescript/src/types.ts"

typesCodeText :: Text
typesCodeText = ("// API Types: " <> autoGenerated <> "\n") <> foldMap typeCode chatTypesDocs
  where
    typeCode CTDoc {typeDef = td@APITypeDef {typeName' = name, typeDef}, typeDescr, typeSyntax} =
      (if T.null typeDescr then "" else "// " <> typeDescr <> "\n")
        <> typeDefCode
        -- <> (if typeSyntax == "" then "" else syntaxText (name, self : typeFields) typeSyntax)
      where
        self = APIRecordField "self" (ATDef td)
        typeFields = case typeDef of
          ATDRecord fs -> L.toList fs
          ATDUnion ms -> APIRecordField "type" tagType : concatMap (\(ATUnionMember _ fs) -> fs) ms
            where
              tagType = ATDef $ APITypeDef (name <> ".type") $ ATDEnum tags
              tags = L.map (\(ATUnionMember tag _) -> tag) ms
          ATDEnum _ -> []
        name' = T.pack name
        constrName tag = case name of
          "ConnectionMode" -> T.pack $ map toUpper tag
          "FileProtocol" -> T.pack $ map toUpper tag
          _ -> T.replace "-" "_" $ T.pack $ fstToUpper tag
        funcCode = "\n  export function cmdString(self: " <> name' <> "): string {\n    return " <> jsSyntaxText True (name, self : typeFields) typeSyntax <> "\n  }\n"
        namespaceFuncCode = "\nexport namespace " <> name' <> "{" <> funcCode <> "}\n"
        typeDefCode = case typeDef of
          ATDRecord fields ->
            ("\nexport interface " <> name' <> " {\n")
              <> fieldsCode "" (L.toList fields)
              <> "}\n"
              <> (if typeSyntax == "" then "" else namespaceFuncCode)
          ATDEnum cs ->
            ("\nexport enum " <> name' <> " {\n")
              <> foldMap (\m -> "  " <> constrName m <> " = \"" <> T.pack m <> "\",\n") cs
              <> "}\n"
              <> (if typeSyntax == "" then "" else namespaceFuncCode)
          (ATDUnion cs) -> -- "\n**Discriminated union type**:\n" <> foldMap constrText cs
            ("\nexport type " <> name' <> " = " <> constrsCode "" constrTypeRef <> "\n")
              <> ("export namespace " <> name' <> "{\n")
              <> ("  export type Tag = " <> constrsCode "  " constrTag <> "\n")
              <> ("  interface Interface {\n    type: Tag\n  }\n")
              <> foldMap constrType cs
              <> (if typeSyntax == "" then "" else funcCode)
              <> "}\n"
              -- <> ("\nexport interface " <> name' <> " {\n}\n")
            where
              constrsCode indent constr
                | T.length (name' <> " = " <> line) <= 100 = line <> "\n"
                | otherwise = "\n" <> foldMap (\c -> indent <> "  | " <> c <> "\n") constrs
                where
                  line = T.intercalate " | " constrs
                  constrs = map constr $ L.toList cs
              constrTypeRef (ATUnionMember tag _) = name' <> "." <> constrName tag
              constrTag (ATUnionMember tag _) = T.pack $ "\"" <> tag <> "\""
              constrType c@(ATUnionMember tag fields) =
                ("\n  export interface " <> constrName tag <> " extends Interface {\n")
                  <> "    type: " <> constrTag c <> "\n"
                  <> fieldsCode "  " fields
                  <> "  }\n"


fieldsCode :: Text -> [APIRecordField] -> Text
fieldsCode indent = foldMap $ (indent <>) . T.pack . fieldText
  where
    fieldText (APIRecordField name t) = "  " <> name <> optional t <> ": " <> typeText t <> typeComment t <> "\n"
    optional = \case
      ATOptional _ -> "?"
      _ -> ""
    typeText = \case
      ATPrim (PT t) -> typeName t
      ATDef (APITypeDef t _) -> t
      ATRef t -> t
      ATOptional t -> typeText t
      ATArray {elemType} -> "[" <> typeText elemType <> "]"
      ATMap (PT t) valueType -> "{[key: " <> typeName t <> "]: " <> typeText valueType <> "}"
    typeName = \case
      TBool -> "boolean"
      TInt -> "number"
      TInt64 -> "number"
      TWord32 -> "number"
      TDouble -> "number"
      TJSONObject -> "object"
      TUTCTime -> "string"
      t -> t
    typeComment t = let c = typeComment' t in if null c then "" else " // " <> c
    typeComment' = \case
      ATPrim (PT t) -> typeComment_ t
      ATOptional (ATPrim (PT t)) -> typeComment_ t
      ATArray {elemType, nonEmpty}
        | nonEmpty -> (if null c then "" else c <> ", ") <> "non-empty"
        | otherwise -> c
        where
          c = typeComment' elemType
      ATMap (PT k) v ->
        let kc = typeComment_ k
            vc = typeComment' v
            tc t c = if null c then t else c
         in if null kc && null vc then "" else tc (typeName k) kc <> " : " <> tc (typeText v) vc
      _ -> ""
    typeComment_ = \case
      TInt -> "int"
      TInt64 -> "int64"
      TWord32 -> "word32"
      TDouble -> "double"
      TUTCTime -> "ISO-8601 timestamp"
      _ -> ""
