# Community Vouchers contract

This document simplifies [the previous RFC](./2025-10-23-vouchers.md) in two ways:
- only one type of credits (previous design had conversion from community to operator credits).
- vouchers can support any amount and change.
- using a single fixed-size Merkle tree for vouchers.
- proposal for balancing privacy and the size of the tree that the client has to load.

## Objectives

- voucher expiration - fixed period per contract.
- limit the number of transactions for the vouchers.
- vouchers support any amount.
- allow redeeming part of the voucher, with change.

## Design proposal

### General ideas

- Voucher is issued by the smart contract in exchange for stable-coin deposit, and recorded as blinded commitment added to Merkle tree.
- Voucher is nominated in USD with 18 decimals, as all ETH tokens.
- Voucher transactions and redemptions (partial or full) is done via zero-knowledge proof and recorded as nullifier to prevent double spends, with the new commitment for the remaining amount and transaction count (can be 0).
- Commitment includes:
  - the amount.
  - the remaining number of allowed transactions.
  - the expiration time.
- Merkle tree of commitments has a fixed depth of say 20-40 levels (for approx 10^6-10^12 voucher capacity).
- Transactions and redemptions should prove consistency between the old and new commitments, without revealing them, and include the nullifier to prevent double spends.
- Redemptions also include the blockchain address and ID of the operator.
- Release of funds with revenue sharing can be done via call to another contract.

### Data storage

Smart contract:
- total deposit amounts bucketed by time ranges (to allow the release of funds to network after expiration).
- nullifiers bucketed by creation time (to allow removing old nullifiers).
- the path in the Merkle tree on "the front" of the filled part of the tree.
- multiple last Merkle tree roots:
  - to accept the proof after the root changes.
  - to frustrate timing correlation by computing proofs in advance (for better usability).

Transaction event log:
- Merkle tree of commitments are recorded in event log

### Voucher lifecycle

1. Issuance: blinded commitment recorded as described above in exchange for stablecoin deposit.

The contract should be able to verify that:
- commitment amount is the same as deposit amount.
- expiration time is in 12 months from now (possibly rounded up to 1-3 months).
- transaction count is correct.

Questions:
1) what would be deposit UX initially (MVP)?


2. Computing zero-knowledge proof for transaction or redemption.

To compute the proof the client needs to have a path from commitment to tree root.

As the path to commitment changes when the tree gets filled, we need to find a balance between privacy and usability - to request as little as possible and have as large anonymity set as possible.


3. Transaction.

Includes 2 new commitments (to destination and a "change") and nullifier are submitted.

ZK proof should prove that:
- the old commitment expiration time is greater than transaction submission time (possibly has to be included in parameters to be part of the proof).
- the total amount of 2 new commitments is the same as the amount of nullified old commitment.
- the new commitments expiration time is the same as the old.
- the old commitment remaining transaction count is greater than 0.
- the new commitments remaining transaction count is reduced by one.

Questions:
1) how would the transaction recipient know that it received a transaction?
2) do we want to conceal who made the donation? If not, it can be a message from the member to group owners.
3) do we want to conceal from the relays when and to which group donation was made?
4) can we have view keys to delegate the detection of incoming transactions to relays?
5) should we round expiration time to a month or even 3 months? (to avoid exposing expiration time to the transaction recipient, as it also leaks purchase time)


4. Redemption.

Includes one new commitment (with the change) and public record of funds released to operator and network.

The revenues received by the operators are publicly visible.

ZK proof should prove that:
- the old commitment expiration time is greater than transaction submission time.
- the total amount of the new commitment and of released funds is the same as the amount of nullified commitment.
- the new commitment expiration time is the same as the old.
- the old commitment remaining transaction count is greater than or equal to 0.
- the new commitment remaining transaction count is the same as the initial.


5. Releasing deposits for expired vouchers to the network.

Question: how do we know which of the old funds were used and which not?
